//
//  DistributedVersionControl.swift
//  CloudDriveCore
//
//  分布式版本控制系统 - 类似Git的分支和合并功能
//

import Foundation
import CryptoKit

// MARK: - 版本控制基础结构

/// 提交对象
public struct Commit: Codable, Identifiable {
    public let id: String // SHA-256 哈希
    public let parentIds: [String] // 父提交ID
    public let treeId: String // 文件树ID
    public let author: Author
    public let committer: Author
    public let message: String
    public let timestamp: Date
    public let metadata: [String: String]
    
    public init(
        parentIds: [String] = [],
        treeId: String,
        author: Author,
        committer: Author? = nil,
        message: String,
        metadata: [String: String] = [:]
    ) {
        self.parentIds = parentIds
        self.treeId = treeId
        self.author = author
        self.committer = committer ?? author
        self.message = message
        self.timestamp = Date()
        self.metadata = metadata
        
        // 计算提交ID
        let data = "\(parentIds.joined(separator:","))\(treeId)\(author.id)\(message)\(timestamp.timeIntervalSince1970)".data(using: .utf8)!
        self.id = SHA256.hash(data: data).compactMap { String(format: "%02x", $0) }.joined()
    }
}

/// 作者信息
public struct Author: Codable {
    public let id: String
    public let name: String
    public let email: String
    public let timestamp: Date
    
    public init(id: String, name: String, email: String) {
        self.id = id
        self.name = name
        self.email = email
        self.timestamp = Date()
    }
}

/// 文件树对象
public struct Tree: Codable, Identifiable {
    public let id: String
    public let entries: [TreeEntry]
    
    public init(entries: [TreeEntry]) {
        self.entries = entries.sorted { $0.name < $1.name }
        
        // 计算树ID
        let entriesData = self.entries.map { "\($0.mode)\($0.name)\($0.id)" }.joined()
        let data = entriesData.data(using: .utf8)!
        self.id = SHA256.hash(data: data).compactMap { String(format: "%02x", $0) }.joined()
    }
}

/// 文件树条目
public struct TreeEntry: Codable {
    public let mode: FileMode
    public let name: String
    public let id: String // 文件或子树的ID
    public let type: ObjectType
    
    public init(mode: FileMode, name: String, id: String, type: ObjectType) {
        self.mode = mode
        self.name = name
        self.id = id
        self.type = type
    }
}

/// 文件模式
public enum FileMode: String, Codable {
    case regularFile = "100644"
    case executableFile = "100755"
    case symbolicLink = "120000"
    case directory = "040000"
    case submodule = "160000"
}

/// 对象类型
public enum ObjectType: String, Codable {
    case blob = "blob"
    case tree = "tree"
    case commit = "commit"
    case tag = "tag"
}

/// 文件对象
public struct Blob: Codable, Identifiable {
    public let id: String
    public let content: Data
    public let size: Int64
    public let mimeType: String?
    
    public init(content: Data, mimeType: String? = nil) {
        self.content = content
        self.size = Int64(content.count)
        self.mimeType = mimeType
        
        // 计算文件ID
        self.id = SHA256.hash(data: content).compactMap { String(format: "%02x", $0) }.joined()
    }
}

// MARK: - 分支管理

/// 分支引用
public struct Branch: Codable, Identifiable {
    public let id: String
    public let name: String
    public var commitId: String
    public let createdAt: Date
    public var updatedAt: Date
    public let createdBy: String
    public let isRemote: Bool
    public let upstream: String? // 上游分支
    
    public init(name: String, commitId: String, createdBy: String, isRemote: Bool = false, upstream: String? = nil) {
        self.id = UUID().uuidString
        self.name = name
        self.commitId = commitId
        self.createdAt = Date()
        self.updatedAt = Date()
        self.createdBy = createdBy
        self.isRemote = isRemote
        self.upstream = upstream
    }
    
    public mutating func updateCommit(_ newCommitId: String) {
        self.commitId = newCommitId
        self.updatedAt = Date()
    }
}

/// 标签
public struct Tag: Codable, Identifiable {
    public let id: String
    public let name: String
    public let commitId: String
    public let message: String?
    public let tagger: Author
    public let createdAt: Date
    
    public init(name: String, commitId: String, message: String? = nil, tagger: Author) {
        self.id = UUID().uuidString
        self.name = name
        self.commitId = commitId
        self.message = message
        self.tagger = tagger
        self.createdAt = Date()
    }
}

// MARK: - 合并策略

/// 合并策略
public enum MergeStrategy: String, CaseIterable, Codable {
    case fastForward = "fast_forward"           // 快进合并
    case recursive = "recursive"               // 递归合并
    case octopus = "octopus"                   // 章鱼合并（多分支）
    case ours = "ours"                         // 使用我们的版本
    case theirs = "theirs"                     // 使用他们的版本
    case subtree = "subtree"                   // 子树合并
    
    public var description: String {
        switch self {
        case .fastForward: return "快进合并"
        case .recursive: return "递归合并"
        case .octopus: return "章鱼合并"
        case .ours: return "使用我们的版本"
        case .theirs: return "使用他们的版本"
        case .subtree: return "子树合并"
        }
    }
}

/// 合并结果
public struct MergeResult {
    public let success: Bool
    public let mergeCommit: Commit?
    public let conflicts: [MergeConflict]
    public let strategy: MergeStrategy
    public let message: String
    
    public init(success: Bool, mergeCommit: Commit? = nil, conflicts: [MergeConflict] = [], strategy: MergeStrategy, message: String) {
        self.success = success
        self.mergeCommit = mergeCommit
        self.conflicts = conflicts
        self.strategy = strategy
        self.message = message
    }
}

/// 合并冲突
public struct MergeConflict {
    public let filePath: String
    public let baseContent: String?
    public let oursContent: String
    public let theirsContent: String
    public let conflictMarkers: [ConflictMarker]
    
    public init(filePath: String, baseContent: String?, oursContent: String, theirsContent: String, conflictMarkers: [ConflictMarker] = []) {
        self.filePath = filePath
        self.baseContent = baseContent
        self.oursContent = oursContent
        self.theirsContent = theirsContent
        self.conflictMarkers = conflictMarkers
    }
}

/// 冲突标记
public struct ConflictMarker {
    public let startLine: Int
    public let endLine: Int
    public let type: ConflictType
    
    public enum ConflictType {
        case ours, theirs, base
    }
}

// MARK: - 分布式版本控制系统

/// 分布式版本控制系统
public class DistributedVersionControl {
    private var commits: [String: Commit] = [:]
    private var trees: [String: Tree] = [:]
    private var blobs: [String: Blob] = [:]
    private var branches: [String: Branch] = [:]
    private var tags: [String: Tag] = [:]
    private var currentBranch: String = "main"
    
    private let deviceId: String
    private let userId: String
    private let author: Author
    
    public init(deviceId: String, userId: String, author: Author) {
        self.deviceId = deviceId
        self.userId = userId
        self.author = author
        
        // 创建默认主分支
        createInitialCommit()
    }
    
    private func createInitialCommit() {
        let emptyTree = Tree(entries: [])
        trees[emptyTree.id] = emptyTree
        
        let initialCommit = Commit(
            treeId: emptyTree.id,
            author: author,
            message: "Initial commit"
        )
        commits[initialCommit.id] = initialCommit
        
        let mainBranch = Branch(
            name: "main",
            commitId: initialCommit.id,
            createdBy: userId
        )
        branches["main"] = mainBranch
    }
    
    // MARK: - 基础操作
    
    /// 创建文件对象
    public func createBlob(content: Data, mimeType: String? = nil) -> String {
        let blob = Blob(content: content, mimeType: mimeType)
        blobs[blob.id] = blob
        return blob.id
    }
    
    /// 创建文件树
    public func createTree(entries: [TreeEntry]) -> String {
        let tree = Tree(entries: entries)
        trees[tree.id] = tree
        return tree.id
    }
    
    /// 创建提交
    public func createCommit(
        parentIds: [String] = [],
        treeId: String,
        message: String,
        metadata: [String: String] = [:]
    ) -> String {
        let commit = Commit(
            parentIds: parentIds,
            treeId: treeId,
            author: author,
            message: message,
            metadata: metadata
        )
        commits[commit.id] = commit
        return commit.id
    }
    
    /// 获取提交
    public func getCommit(_ id: String) -> Commit? {
        return commits[id]
    }
    
    /// 获取文件树
    public func getTree(_ id: String) -> Tree? {
        return trees[id]
    }
    
    /// 获取文件对象
    public func getBlob(_ id: String) -> Blob? {
        return blobs[id]
    }
    
    // MARK: - 分支操作
    
    /// 创建分支
    public func createBranch(_ name: String, fromCommit commitId: String? = nil) -> Bool {
        guard branches[name] == nil else { return false }
        
        let baseCommitId = commitId ?? getCurrentCommitId()
        guard commits[baseCommitId] != nil else { return false }
        
        let branch = Branch(name: name, commitId: baseCommitId, createdBy: userId)
        branches[name] = branch
        return true
    }
    
    /// 切换分支
    public func checkoutBranch(_ name: String) -> Bool {
        guard branches[name] != nil else { return false }
        currentBranch = name
        return true
    }
    
    /// 删除分支
    public func deleteBranch(_ name: String) -> Bool {
        guard name != "main" && name != currentBranch else { return false }
        branches.removeValue(forKey: name)
        return true
    }
    
    /// 获取当前分支
    public func getCurrentBranch() -> Branch? {
        return branches[currentBranch]
    }
    
    /// 获取当前提交ID
    public func getCurrentCommitId() -> String {
        return branches[currentBranch]?.commitId ?? ""
    }
    
    /// 更新分支指向
    public func updateBranch(_ name: String, to commitId: String) -> Bool {
        guard var branch = branches[name] else { return false }
        guard commits[commitId] != nil else { return false }
        
        branch.updateCommit(commitId)
        branches[name] = branch
        return true
    }
    
    // MARK: - 合并操作
    
    /// 合并分支
    public func merge(
        from sourceBranch: String,
        to targetBranch: String? = nil,
        strategy: MergeStrategy = .recursive,
        message: String? = nil
    ) -> MergeResult {
        let target = targetBranch ?? currentBranch
        
        guard let sourceBranchObj = branches[sourceBranch],
              let targetBranchObj = branches[target] else {
            return MergeResult(
                success: false,
                strategy: strategy,
                message: "分支不存在"
            )
        }
        
        let sourceCommitId = sourceBranchObj.commitId
        let targetCommitId = targetBranchObj.commitId
        
        // 检查是否可以快进合并
        if strategy == .fastForward || canFastForward(from: targetCommitId, to: sourceCommitId) {
            return performFastForwardMerge(
                sourceBranch: sourceBranch,
                targetBranch: target,
                sourceCommitId: sourceCommitId
            )
        }
        
        // 执行三路合并
        return performThreeWayMerge(
            sourceBranch: sourceBranch,
            targetBranch: target,
            sourceCommitId: sourceCommitId,
            targetCommitId: targetCommitId,
            strategy: strategy,
            message: message
        )
    }
    
    private func canFastForward(from baseCommitId: String, to targetCommitId: String) -> Bool {
        // 检查目标提交是否是基础提交的后代
        return isAncestor(ancestor: baseCommitId, descendant: targetCommitId)
    }
    
    private func isAncestor(ancestor: String, descendant: String) -> Bool {
        guard let descendantCommit = commits[descendant] else { return false }
        
        if descendantCommit.parentIds.contains(ancestor) {
            return true
        }
        
        for parentId in descendantCommit.parentIds {
            if isAncestor(ancestor: ancestor, descendant: parentId) {
                return true
            }
        }
        
        return false
    }
    
    private func performFastForwardMerge(
        sourceBranch: String,
        targetBranch: String,
        sourceCommitId: String
    ) -> MergeResult {
        guard updateBranch(targetBranch, to: sourceCommitId) else {
            return MergeResult(
                success: false,
                strategy: .fastForward,
                message: "无法更新分支指向"
            )
        }
        
        return MergeResult(
            success: true,
            strategy: .fastForward,
            message: "快进合并完成"
        )
    }
    
    private func performThreeWayMerge(
        sourceBranch: String,
        targetBranch: String,
        sourceCommitId: String,
        targetCommitId: String,
        strategy: MergeStrategy,
        message: String?
    ) -> MergeResult {
        // 找到共同祖先
        guard let baseCommitId = findCommonAncestor(commit1: sourceCommitId, commit2: targetCommitId) else {
            return MergeResult(
                success: false,
                strategy: strategy,
                message: "无法找到共同祖先"
            )
        }
        
        // 获取三个版本的文件树
        guard let baseCommit = commits[baseCommitId],
              let sourceCommit = commits[sourceCommitId],
              let targetCommit = commits[targetCommitId],
              let baseTree = trees[baseCommit.treeId],
              let sourceTree = trees[sourceCommit.treeId],
              let targetTree = trees[targetCommit.treeId] else {
            return MergeResult(
                success: false,
                strategy: strategy,
                message: "无法获取文件树"
            )
        }
        
        // 执行三路合并
        let mergeTreeResult = mergeTree(base: baseTree, ours: targetTree, theirs: sourceTree)
        
        if !mergeTreeResult.conflicts.isEmpty {
            return MergeResult(
                success: false,
                conflicts: mergeTreeResult.conflicts,
                strategy: strategy,
                message: "存在合并冲突"
            )
        }
        
        // 创建合并提交
        let mergeMessage = message ?? "Merge branch '\(sourceBranch)' into '\(targetBranch)'"
        let mergeCommitId = createCommit(
            parentIds: [targetCommitId, sourceCommitId],
            treeId: mergeTreeResult.treeId,
            message: mergeMessage
        )
        
        // 更新目标分支
        guard updateBranch(targetBranch, to: mergeCommitId) else {
            return MergeResult(
                success: false,
                strategy: strategy,
                message: "无法更新分支指向"
            )
        }
        
        return MergeResult(
            success: true,
            mergeCommit: commits[mergeCommitId],
            strategy: strategy,
            message: "合并完成"
        )
    }
    
    private func findCommonAncestor(commit1: String, commit2: String) -> String? {
        // 简化的共同祖先查找算法
        let ancestors1 = getAncestors(commitId: commit1)
        let ancestors2 = getAncestors(commitId: commit2)
        
        // 找到最近的共同祖先
        for ancestor1 in ancestors1 {
            if ancestors2.contains(ancestor1) {
                return ancestor1
            }
        }
        
        return nil
    }
    
    private func getAncestors(commitId: String) -> [String] {
        var ancestors: [String] = []
        var queue: [String] = [commitId]
        var visited: Set<String> = []
        
        while !queue.isEmpty {
            let currentId = queue.removeFirst()
            
            if visited.contains(currentId) {
                continue
            }
            
            visited.insert(currentId)
            ancestors.append(currentId)
            
            if let commit = commits[currentId] {
                queue.append(contentsOf: commit.parentIds)
            }
        }
        
        return ancestors
    }
    
    private func mergeTree(base: Tree, ours: Tree, theirs: Tree) -> TreeMergeResult {
        var mergedEntries: [TreeEntry] = []
        var conflicts: [MergeConflict] = []
        
        // 收集所有文件路径
        let allPaths = Set(base.entries.map { $0.name })
            .union(Set(ours.entries.map { $0.name }))
            .union(Set(theirs.entries.map { $0.name }))
        
        for path in allPaths {
            let baseEntry = base.entries.first { $0.name == path }
            let oursEntry = ours.entries.first { $0.name == path }
            let theirsEntry = theirs.entries.first { $0.name == path }
            
            let mergeResult = mergeEntry(
                path: path,
                base: baseEntry,
                ours: oursEntry,
                theirs: theirsEntry
            )
            
            if let entry = mergeResult.entry {
                mergedEntries.append(entry)
            }
            
            if let conflict = mergeResult.conflict {
                conflicts.append(conflict)
            }
        }
        
        let mergedTree = Tree(entries: mergedEntries)
        trees[mergedTree.id] = mergedTree
        
        return TreeMergeResult(
            treeId: mergedTree.id,
            conflicts: conflicts
        )
    }
    
    private func mergeEntry(
        path: String,
        base: TreeEntry?,
        ours: TreeEntry?,
        theirs: TreeEntry?
    ) -> EntryMergeResult {
        switch (base, ours, theirs) {
        case (nil, let ours?, nil):
            // 我们添加的文件
            return EntryMergeResult(entry: ours)
            
        case (nil, nil, let theirs?):
            // 他们添加的文件
            return EntryMergeResult(entry: theirs)
            
        case (let base?, nil, nil):
            // 双方都删除的文件
            return EntryMergeResult(entry: nil)
            
        case (let base?, let ours?, nil):
            // 他们删除，我们修改
            if base.id == ours.id {
                // 我们没有修改，接受删除
                return EntryMergeResult(entry: nil)
            } else {
                // 我们修改了，产生冲突
                return createDeleteModifyConflict(path: path, base: base, modified: ours, isOursModified: true)
            }
            
        case (let base?, nil, let theirs?):
            // 我们删除，他们修改
            if base.id == theirs.id {
                // 他们没有修改，接受删除
                return EntryMergeResult(entry: nil)
            } else {
                // 他们修改了，产生冲突
                return createDeleteModifyConflict(path: path, base: base, modified: theirs, isOursModified: false)
            }
            
        case (let base?, let ours?, let theirs?):
            // 三方都存在
            if ours.id == theirs.id {
                // 双方修改相同，无冲突
                return EntryMergeResult(entry: ours)
            } else if base.id == ours.id {
                // 我们没有修改，使用他们的版本
                return EntryMergeResult(entry: theirs)
            } else if base.id == theirs.id {
                // 他们没有修改，使用我们的版本
                return EntryMergeResult(entry: ours)
            } else {
                // 双方都修改了，产生冲突
                return createModifyModifyConflict(path: path, base: base, ours: ours, theirs: theirs)
            }
            
        default:
            // 不应该到达这里
            return EntryMergeResult(entry: nil)
        }
    }
    
    private func createDeleteModifyConflict(
        path: String,
        base: TreeEntry,
        modified: TreeEntry,
        isOursModified: Bool
    ) -> EntryMergeResult {
        let baseContent = getFileContent(entryId: base.id) ?? ""
        let modifiedContent = getFileContent(entryId: modified.id) ?? ""
        
        let conflict = MergeConflict(
            filePath: path,
            baseContent: baseContent,
            oursContent: isOursModified ? modifiedContent : "",
            theirsContent: isOursModified ? "" : modifiedContent
        )
        
        return EntryMergeResult(conflict: conflict)
    }
    
    private func createModifyModifyConflict(
        path: String,
        base: TreeEntry,
        ours: TreeEntry,
        theirs: TreeEntry
    ) -> EntryMergeResult {
        let baseContent = getFileContent(entryId: base.id) ?? ""
        let oursContent = getFileContent(entryId: ours.id) ?? ""
        let theirsContent = getFileContent(entryId: theirs.id) ?? ""
        
        let conflict = MergeConflict(
            filePath: path,
            baseContent: baseContent,
            oursContent: oursContent,
            theirsContent: theirsContent
        )
        
        return EntryMergeResult(conflict: conflict)
    }
    
    private func getFileContent(entryId: String) -> String? {
        guard let blob = blobs[entryId] else { return nil }
        return String(data: blob.content, encoding: .utf8)
    }
    
    // MARK: - 标签操作
    
    /// 创建标签
    public func createTag(_ name: String, commitId: String? = nil, message: String? = nil) -> Bool {
        guard tags[name] == nil else { return false }
        
        let targetCommitId = commitId ?? getCurrentCommitId()
        guard commits[targetCommitId] != nil else { return false }
        
        let tag = Tag(name: name, commitId: targetCommitId, message: message, tagger: author)
        tags[name] = tag
        return true
    }
    
    /// 删除标签
    public func deleteTag(_ name: String) -> Bool {
        tags.removeValue(forKey: name) != nil
    }
    
    /// 获取标签
    public func getTag(_ name: String) -> Tag? {
        return tags[name]
    }
    
    // MARK: - 历史查询
    
    /// 获取提交历史
    public func getCommitHistory(from commitId: String? = nil, limit: Int = 100) -> [Commit] {
        let startCommitId = commitId ?? getCurrentCommitId()
        var history: [Commit] = []
        var queue: [String] = [startCommitId]
        var visited: Set<String> = []
        
        while !queue.isEmpty && history.count < limit {
            let currentId = queue.removeFirst()
            
            if visited.contains(currentId) {
                continue
            }
            
            visited.insert(currentId)
            
            if let commit = commits[currentId] {
                history.append(commit)
                queue.append(contentsOf: commit.parentIds)
            }
        }
        
        return history.sorted { $0.timestamp > $1.timestamp }
    }
    
    /// 获取分支列表
    public func getBranches() -> [Branch] {
        return Array(branches.values).sorted { $0.name < $1.name }
    }
    
    /// 获取标签列表
    public func getTags() -> [Tag] {
        return Array(tags.values).sorted { $0.name < $1.name }
    }
    
    // MARK: - 同步操作
    
    /// 推送到远程
    public func push(branch: String, remote: String) -> Bool {
        // 这里应该实现推送到远程仓库的逻辑
        // 简化实现，只是标记为成功
        return true
    }
    
    /// 从远程拉取
    public func pull(branch: String, remote: String) -> Bool {
        // 这里应该实现从远程仓库拉取的逻辑
        // 简化实现，只是标记为成功
        return true
    }
    
    /// 获取远程分支
    public func fetchRemoteBranches(remote: String) -> [Branch] {
        // 这里应该实现获取远程分支的逻辑
        // 简化实现，返回空数组
        return []
    }
}

// MARK: - 辅助结构

private struct TreeMergeResult {
    let treeId: String
    let conflicts: [MergeConflict]
}

private struct EntryMergeResult {
    let entry: TreeEntry?
    let conflict: MergeConflict?
    
    init(entry: TreeEntry?) {
        self.entry = entry
        self.conflict = nil
    }
    
    init(conflict: MergeConflict) {
        self.entry = nil
        self.conflict = conflict
    }
}